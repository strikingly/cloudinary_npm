// Generated by CoffeeScript 1.12.7
(function() {
  var DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION, LAYER_KEYWORD_PARAMS, _, build_custom_headers, build_eager, config, finalize_resource_type, finalize_source, hashToQuery, join_pair, norm_range_value, number_pattern, offset_any_pattern, offset_any_pattern_re, process_video_params, querystring, smart_escape, split_range, textStyle, unsigned_url_prefix, utils;

  _ = require("lodash");

  config = require("./config");

  querystring = require('querystring');

  utils = exports;

  exports.CF_SHARED_CDN = "d3jpl91pxevbkh.cloudfront.net";

  exports.OLD_AKAMAI_SHARED_CDN = "cloudinary-a.akamaihd.net";

  exports.AKAMAI_SHARED_CDN = "res.cloudinary.com";

  exports.SHARED_CDN = exports.AKAMAI_SHARED_CDN;

  exports.VERSION = "1.3.0";

  exports.USER_AGENT = "CloudinaryNodeJS/" + exports.VERSION;

  exports.userPlatform = "";

  exports.getUserAgent = function() {
    if (_.isEmpty(utils.userPlatform)) {
      return "" + utils.USER_AGENT;
    } else {
      return utils.userPlatform + " " + utils.USER_AGENT;
    }
  };

  DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION = {
    width: "auto",
    crop: "limit"
  };

  exports.DEFAULT_POSTER_OPTIONS = {
    format: 'jpg',
    resource_type: 'video'
  };

  exports.DEFAULT_VIDEO_SOURCE_TYPES = ['webm', 'mp4', 'ogv'];

  LAYER_KEYWORD_PARAMS = {
    font_weight: "normal",
    font_style: "normal",
    text_decoration: "none",
    text_align: null,
    stroke: "none"
  };

  textStyle = function(layer) {
    var attr, attr_value, default_value, font_family, font_size, keywords, letter_spacing, line_spacing;
    font_family = layer["font_family"];
    font_size = layer["font_size"];
    keywords = [];
    for (attr in LAYER_KEYWORD_PARAMS) {
      default_value = LAYER_KEYWORD_PARAMS[attr];
      attr_value = layer[attr] || default_value;
      if (attr_value !== default_value) {
        keywords.push(attr_value);
      }
    }
    letter_spacing = layer["letter_spacing"];
    if (letter_spacing) {
      keywords.push("letter_spacing_" + letter_spacing);
    }
    line_spacing = layer["line_spacing"];
    if (line_spacing) {
      keywords.push("line_spacing_" + line_spacing);
    }
    if (font_size || font_family || !_.isEmpty(keywords)) {
      if (!font_family) {
        raise(CloudinaryException, "Must supply font_family for text in overlay/underlay");
      }
      if (!font_size) {
        raise(CloudinaryException, "Must supply font_size for text in overlay/underlay");
      }
      keywords.unshift(font_size);
      keywords.unshift(font_family);
      return _.compact(keywords).join("_");
    }
  };

  exports.timestamp = function() {
    return Math.floor(new Date().getTime() / 1000);
  };


  /**
   * Deletes `option_name` from `options` and return the value if present.
   * If `options` doesn't contain `option_name` the default value is returned.
   * @param {Object} options a collection
   * @param {String} option_name the name (key) of the desired value
   * @param [default_value] the value to return is option_name is missing
   */

  exports.option_consume = function(options, option_name, default_value) {
    var result;
    result = options[option_name];
    delete options[option_name];
    if (result != null) {
      return result;
    } else {
      return default_value;
    }
  };

  exports.build_array = function(arg) {
    if (arg == null) {
      return [];
    } else if (_.isArray(arg)) {
      return arg;
    } else {
      return [arg];
    }
  };

  exports.encode_double_array = function(array) {
    array = utils.build_array(array);
    if (array.length > 0 && _.isArray(array[0])) {
      return array.map(function(e) {
        return utils.build_array(e).join(",");
      }).join("|");
    } else {
      return array.join(",");
    }
  };

  exports.encode_key_value = function(arg) {
    var k, pairs, v;
    if (_.isObject(arg)) {
      pairs = (function() {
        var results;
        results = [];
        for (k in arg) {
          v = arg[k];
          results.push(k + "=" + v);
        }
        return results;
      })();
      return pairs.join("|");
    } else {
      return arg;
    }
  };

  exports.build_eager = function(transformations) {
    var transformation;
    return ((function() {
      var i, len, ref, results;
      ref = utils.build_array(transformations);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        transformation = ref[i];
        transformation = _.clone(transformation);
        results.push(_.filter([utils.generate_transformation_string(transformation), transformation.format], utils.present).join("/"));
      }
      return results;
    })()).join("|");
  };

  exports.build_custom_headers = function(headers) {
    var k, v;
    switch (false) {
      case !(headers == null):
        return void 0;
      case !_.isArray(headers):
        return headers.join("\n");
      case !_.isObject(headers):
        return [
          (function() {
            var results;
            results = [];
            for (k in headers) {
              v = headers[k];
              results.push(k + ": " + v);
            }
            return results;
          })()
        ].join("\n");
      default:
        return headers;
    }
  };

  exports.present = function(value) {
    return !_.isUndefined(value) && ("" + value).length > 0;
  };

  exports.generate_transformation_string = function(options) {
    var angle, background, base_transformation, base_transformations, border, color, crop, dpr, effect, flags, has_layer, height, key, named_transformation, no_html_sizes, param, params, ref, ref1, ref2, ref3, ref4, responsive_width, responsive_width_transformation, result, short, simple_params, size, transformations, value, width;
    if (_.isArray(options)) {
      result = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = options.length; i < len; i++) {
          base_transformation = options[i];
          results.push(utils.generate_transformation_string(_.clone(base_transformation)));
        }
        return results;
      })();
      return result.join("/");
    }
    responsive_width = utils.option_consume(options, "responsive_width", config().responsive_width);
    width = options["width"];
    height = options["height"];
    size = utils.option_consume(options, "size");
    if (size) {
      ref1 = (ref = size.split("x"), width = ref[0], height = ref[1], ref), options["width"] = ref1[0], options["height"] = ref1[1];
    }
    has_layer = options.overlay || options.underlay;
    crop = utils.option_consume(options, "crop");
    angle = utils.build_array(utils.option_consume(options, "angle")).join(".");
    no_html_sizes = has_layer || utils.present(angle) || crop === "fit" || crop === "limit" || responsive_width;
    if (width && (width === "auto" || no_html_sizes || parseFloat(width) < 1)) {
      delete options["width"];
    }
    if (height && (no_html_sizes || parseFloat(height) < 1)) {
      delete options["height"];
    }
    background = utils.option_consume(options, "background");
    background = background && background.replace(/^#/, "rgb:");
    color = utils.option_consume(options, "color");
    color = color && color.replace(/^#/, "rgb:");
    base_transformations = utils.build_array(utils.option_consume(options, "transformation", []));
    named_transformation = [];
    if (_.filter(base_transformations, _.isObject).length > 0) {
      base_transformations = _.map(base_transformations, function(base_transformation) {
        if (_.isObject(base_transformation)) {
          return utils.generate_transformation_string(_.clone(base_transformation));
        } else {
          return utils.generate_transformation_string({
            transformation: base_transformation
          });
        }
      });
    } else {
      named_transformation = base_transformations.join(".");
      base_transformations = [];
    }
    effect = utils.option_consume(options, "effect");
    if (_.isArray(effect)) {
      effect = effect.join(":");
    } else if (_.isObject(effect)) {
      for (key in effect) {
        value = effect[key];
        effect = key + ":" + value;
      }
    }
    border = utils.option_consume(options, "border");
    if (_.isObject(border)) {
      border = ((ref2 = border.width) != null ? ref2 : 2) + "px_solid_" + (((ref3 = border.color) != null ? ref3 : "black").replace(/^#/, 'rgb:'));
    } else if (/^\d+$/.exec(border)) {
      options.border = border;
      border = void 0;
    }
    flags = utils.build_array(utils.option_consume(options, "flags")).join(".");
    dpr = utils.option_consume(options, "dpr", config().dpr);
    if (options["offset"] != null) {
      ref4 = split_range(utils.option_consume(options, "offset")), options["start_offset"] = ref4[0], options["end_offset"] = ref4[1];
    }
    params = {
      a: angle,
      b: background,
      bo: border,
      c: crop,
      co: color,
      dpr: dpr,
      e: effect,
      fl: flags,
      h: height,
      t: named_transformation,
      w: width
    };
    simple_params = {
      aspect_ratio: "ar",
      audio_codec: "ac",
      audio_frequency: "af",
      bit_rate: 'br',
      color_space: "cs",
      default_image: "d",
      delay: "dl",
      density: "dn",
      duration: "du",
      end_offset: "eo",
      fetch_format: "f",
      gravity: "g",
      opacity: "o",
      page: "pg",
      prefix: "p",
      quality: "q",
      radius: "r",
      start_offset: "so",
      video_codec: "vc",
      video_sampling: "vs",
      x: "x",
      y: "y",
      zoom: "z"
    };
    for (param in simple_params) {
      short = simple_params[param];
      params[short] = utils.option_consume(options, param);
    }
    params = _.reduce(params, (function(_this) {
      return function(a, v, k) {
        a.push([k, v]);
        return a;
      };
    })(this), []);
    params.push([utils.option_consume(options, "raw_transformation")]);
    transformations = ((function() {
      var i, len, results;
      results = [];
      for (i = 0, len = params.length; i < len; i++) {
        param = params[i];
        if (utils.present(_.last(param))) {
          results.push(param.join("_"));
        }
      }
      return results;
    })()).join(",");
    base_transformations.push(transformations);
    transformations = base_transformations;
    if (responsive_width) {
      responsive_width_transformation = config().responsive_width_transformation || DEFAULT_RESPONSIVE_WIDTH_TRANSFORMATION;
      transformations.push(utils.generate_transformation_string(_.clone(responsive_width_transformation)));
    }
    if (width === "auto" || responsive_width) {
      options.responsive = true;
    }
    if (dpr === "auto") {
      options.hidpi = true;
    }
    return _.filter(transformations, utils.present).join("/");
  };

  exports.url = function(public_id, options) {
    var api_secret, cdn_subdomain, cloud_name, cname, format, original_source, prefix, preloaded, private_cdn, ref, ref1, resource_type, secure, secure_cdn_subdomain, secure_distribution, shorten, sign_url, source_to_sign, ssl_detected, transformation, type, url, url_suffix, use_root_path, version;
    if (options == null) {
      options = {};
    }
    type = utils.option_consume(options, "type", null);
    if (type === "fetch") {
      if (options.fetch_format == null) {
        options.fetch_format = utils.option_consume(options, "format");
      }
    }
    transformation = utils.generate_transformation_string(options);
    resource_type = utils.option_consume(options, "resource_type", "image");
    version = utils.option_consume(options, "version");
    format = utils.option_consume(options, "format");
    cloud_name = utils.option_consume(options, "cloud_name", config().cloud_name);
    if (!cloud_name) {
      throw "Unknown cloud_name";
    }
    private_cdn = utils.option_consume(options, "private_cdn", config().private_cdn);
    secure_distribution = utils.option_consume(options, "secure_distribution", config().secure_distribution);
    secure = utils.option_consume(options, "secure", null);
    ssl_detected = utils.option_consume(options, "ssl_detected", config().ssl_detected);
    if (secure === null) {
      secure = ssl_detected || config().secure;
    }
    cdn_subdomain = utils.option_consume(options, "cdn_subdomain", config().cdn_subdomain);
    secure_cdn_subdomain = utils.option_consume(options, "secure_cdn_subdomain", config().secure_cdn_subdomain);
    cname = utils.option_consume(options, "cname", config().cname);
    shorten = utils.option_consume(options, "shorten", config().shorten);
    sign_url = utils.option_consume(options, "sign_url", config().sign_url);
    api_secret = utils.option_consume(options, "api_secret", config().api_secret);
    url_suffix = utils.option_consume(options, "url_suffix");
    use_root_path = utils.option_consume(options, "use_root_path", config().use_root_path);
    preloaded = /^(image|raw)\/([a-z0-9_]+)\/v(\d+)\/([^#]+)$/.exec(public_id);
    if (preloaded) {
      resource_type = preloaded[1];
      type = preloaded[2];
      version = preloaded[3];
      public_id = preloaded[4];
    }
    if (url_suffix && !private_cdn) {
      throw 'URL Suffix only supported in private CDN';
    }
    original_source = public_id;
    if (public_id == null) {
      return original_source;
    }
    public_id = public_id.toString();
    if (type === null && public_id.match(/^https?:\//i)) {
      return original_source;
    }
    ref = finalize_resource_type(resource_type, type, url_suffix, use_root_path, shorten), resource_type = ref[0], type = ref[1];
    ref1 = finalize_source(public_id, format, url_suffix), public_id = ref1[0], source_to_sign = ref1[1];
    if (source_to_sign.indexOf("/") > 0 && !source_to_sign.match(/^v[0-9]+/) && !source_to_sign.match(/^https?:\//)) {
      if (version == null) {
        version = 1;
      }
    }
    if (version != null) {
      version = "v" + version;
    }
    transformation = transformation.replace(/([^:])\/\//, '\\1\/');
    prefix = unsigned_url_prefix(public_id, cloud_name, private_cdn, cdn_subdomain, secure_cdn_subdomain, cname, secure, secure_distribution);
    url = [prefix, resource_type, type, transformation, version, public_id].filter(function(part) {
      return (part != null) && part !== '';
    }).join('/');
    return url;
  };

  exports.video_url = function(public_id, options) {
    options = _.extend({
      resource_type: 'video'
    }, options);
    return utils.url(public_id, options);
  };

  finalize_source = function(source, format, url_suffix) {
    var source_to_sign;
    source = source.replace(/([^:])\/\//, '\\1\/');
    if (source.match(/^https?:\//i)) {
      source = smart_escape(source);
      source_to_sign = source;
    } else {
      source = smart_escape(decodeURIComponent(source));
      source_to_sign = source;
      if (!!url_suffix) {
        if (url_suffix.match(/[\.\/]/)) {
          throw new Error('url_suffix should not include . or /');
        }
        source = source + '/' + url_suffix;
      }
      if (format != null) {
        source = source + '.' + format;
        source_to_sign = source_to_sign + '.' + format;
      }
    }
    return [source, source_to_sign];
  };

  exports.video_thumbnail_url = function(public_id, options) {
    options = _.extend({}, exports.DEFAULT_POSTER_OPTIONS, options);
    return utils.url(public_id, options);
  };

  finalize_resource_type = function(resource_type, type, url_suffix, use_root_path, shorten) {
    if (type == null) {
      type = 'upload';
    }
    if (url_suffix != null) {
      if (resource_type === 'image' && type === 'upload') {
        resource_type = "images";
        type = null;
      } else if (resource_type === 'raw' && type === 'upload') {
        resource_type = 'files';
        type = null;
      } else {
        throw new Error("URL Suffix only supported for image/upload and raw/upload");
      }
    }
    if (use_root_path) {
      if ((resource_type === 'image' && type === 'upload') || (resource_type === 'images' && (type == null))) {
        resource_type = null;
        type = null;
      } else {
        throw new Error("Root path only supported for image/upload");
      }
    }
    if (shorten && resource_type === 'image' && type === 'upload') {
      resource_type = 'iu';
      type = null;
    }
    return [resource_type, type];
  };

  unsigned_url_prefix = function(source, cloud_name, private_cdn, cdn_subdomain, secure_cdn_subdomain, cname, secure, secure_distribution) {
    var cdn_part, host, prefix, shared_domain, subdomain, subdomain_part;
    if (cloud_name.indexOf("/") === 0) {
      return '/res' + cloud_name;
    }
    shared_domain = !private_cdn;
    if (secure) {
      if ((secure_distribution == null) || secure_distribution === exports.OLD_AKAMAI_SHARED_CDN) {
        secure_distribution = private_cdn ? cloud_name + "-res.cloudinary.com" : exports.SHARED_CDN;
      }
      if (shared_domain == null) {
        shared_domain = secure_distribution === exports.SHARED_CDN;
      }
      if ((secure_cdn_subdomain == null) && shared_domain) {
        secure_cdn_subdomain = cdn_subdomain;
      }
      if (secure_cdn_subdomain) {
        secure_distribution = secure_distribution.replace('res.cloudinary.com', 'res-' + ((crc32(source) % 5) + 1 + '.cloudinary.com'));
      }
      prefix = 'https://' + secure_distribution;
    } else if (cname) {
      subdomain = cdn_subdomain ? 'a' + ((crc32(source) % 5) + 1) + '.' : '';
      prefix = 'http://' + subdomain + cname;
    } else {
      cdn_part = private_cdn ? cloud_name + '-' : '';
      subdomain_part = cdn_subdomain ? '-' + ((crc32(source) % 5) + 1) : '';
      host = [cdn_part, 'res', subdomain_part, '.cloudinary.com'].join('');
      prefix = 'http://' + host;
    }
    if (shared_domain) {
      prefix += '/' + cloud_name;
    }
    return prefix;
  };

  smart_escape = function(string) {
    return encodeURIComponent(string).replace(/%3A/g, ":").replace(/%2F/g, "/");
  };

  exports.merge = function(hash1, hash2) {
    var k, result, v;
    result = {};
    for (k in hash1) {
      v = hash1[k];
      result[k] = hash1[k];
    }
    for (k in hash2) {
      v = hash2[k];
      result[k] = hash2[k];
    }
    return result;
  };

  join_pair = function(key, value) {
    if (!value) {
      return void 0;
    } else if (value === true) {
      return key;
    } else {
      return key + "='" + value + "'";
    }
  };

  exports.html_attrs = function(attrs) {
    var pairs;
    pairs = _.filter(_.map(attrs, function(value, key) {
      return join_pair(key, value);
    }));
    pairs.sort();
    return pairs.join(" ");
  };

  number_pattern = "([0-9]*)\\.([0-9]+)|([0-9]+)";

  offset_any_pattern = "(" + number_pattern + ")([%pP])?";

  offset_any_pattern_re = RegExp("(" + offset_any_pattern + ")\\.\\.(" + offset_any_pattern + ")");

  split_range = function(range) {
    switch (range.constructor) {
      case String:
        if (offset_any_pattern_re = ~range) {
          return range.split("..");
        }
        break;
      case Array:
        return [_.first(range), _.last(range)];
      default:
        return [null, null];
    }
  };


  /**
   * Normalize an offset value
   * @param {String} value a decimal value which may have a 'p' or '%' postfix. E.g. '35%', '0.4p'
   * @return {Object|String} a normalized String of the input value if possible otherwise the value itself
   */

  norm_range_value = function(value) {
    var modifier, offset;
    offset = String(value).match(RegExp("^" + offset_any_pattern + "$"));
    if (offset) {
      modifier = offset[5] ? 'p' : '';
      value = "" + (offset[1] || offset[4]) + modifier;
    }
    return value;
  };


  /**
   * A video codec parameter can be either a String or a Hash.
   * @param {Object} param <code>vc_<codec>[ : <profile> : [<level>]]</code>
   *                       or <code>{ codec: 'h264', profile: 'basic', level: '3.1' }</code>
   * @return {String} <code><codec> : <profile> : [<level>]]</code> if a Hash was provided
   *                   or the param if a String was provided.
   *                   Returns null if param is not a Hash or String
   */

  process_video_params = function(param) {
    var video;
    switch (param.constructor) {
      case Object:
        video = "";
        if ('codec' in param) {
          video = param['codec'];
          if ('profile' in param) {
            video += ":" + param['profile'];
            if ('level' in param) {
              video += ":" + param['level'];
            }
          }
        }
        return video;
      case String:
        return param;
      default:
        return null;
    }
  };

  build_custom_headers = function(headers) {
    var a;
    return ((function() {
      var i, len, ref, results;
      ref = Array(headers);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        a = ref[i];
        if ((a != null ? a.join : void 0) != null) {
          results.push(a.join(": "));
        }
      }
      return results;
    })()).join("\n");
  };


  /**
   * @private
   */

  build_eager = function(eager) {
    var format, ret, transformation;
    if (eager == null) {
      return void 0;
    }
    ret = ((function() {
      var i, len, ref, results;
      ref = Array(eager);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        transformation = ref[i];
        transformation = _.clone(transformation);
        if (transformation.format != null) {
          format = transformation.format;
        }
        delete transformation.format;
        results.push(_.compact([utils.generate_transformation_string(transformation), format]).join("/"));
      }
      return results;
    })()).join("|");
    return ret;
  };

  hashToQuery = function(hash) {
    var key, v, value;
    return _.compact((function() {
      var results;
      results = [];
      for (key in hash) {
        value = hash[key];
        if (_.isArray(value)) {
          results.push(((function() {
            var i, len, results1;
            results1 = [];
            for (i = 0, len = value.length; i < len; i++) {
              v = value[i];
              if (!key.match(/\w+\[\]/)) {
                key = key + "[]";
              }
              results1.push((querystring.escape("" + key)) + "=" + (querystring.escape(v)));
            }
            return results1;
          })()).join("&"));
        } else {
          results.push((querystring.escape(key)) + "=" + (querystring.escape(value)));
        }
      }
      return results;
    })()).sort().join('&');
  };

}).call(this);

//# sourceMappingURL=utils.js.map
